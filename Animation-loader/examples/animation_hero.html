<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://threejs.org/examples/js/loaders/ColladaLoader.js"></script>

<!DOCTYPE html>
<html lang="en">
<head>
	<title>fantasy village</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"/>
	<link type="text/css" rel="stylesheet" href="css/main.css" />
</head>
<section id="loading-screen">

	<div id="loader"></div>
	<div id="info">
		<h1>hello world</h1></div>
</section>
<link rel="stylesheet" href="main.css">
<body>

<div id="container"></div>



<script type="module">

	import * as THREE from '../build/three.module.js';

	import { GUI } from './jsm/libs/dat.gui.module.js';

	import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';

	let scene, renderer, camera;
	let model, mixer, clock;

	const crossFadeControls = [];

	let idleAction, walkAction, runAction;
	let idleWeight, walkWeight, runWeight;
	let actions, settings;

	let singleStepMode = false;
	let sizeOfNextStep = 0;

	init();

	function init() {

		const container = document.getElementById( 'container' );

		camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
		camera.position.set( 1, 2, - 3 );
		camera.lookAt( 0, 1, 0 );



		clock = new THREE.Clock();

		scene = new THREE.Scene();

		const loadingManager = new THREE.LoadingManager( () => {

			const loadingScreen = document.getElementById( 'loading-screen' );
			loadingScreen.classList.add( 'fade-out' );

			// optional: remove loader from DOM via event listener
			loadingScreen.addEventListener( 'transitionend', onTransitionEnd );

		} );

		scene.background = new THREE.Color( 0xB0EBF9 );
		scene.fog = new THREE.Fog( 0xB0EBF9, 10, 50 );

		const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
		hemiLight.position.set( 0, 20, 0 );
		scene.add( hemiLight );

		const dirLight = new THREE.DirectionalLight( 0xffffff );
		dirLight.position.set( - 3, 10, - 10 );
		dirLight.castShadow = true;
		dirLight.shadow.camera.top = 2;
		dirLight.shadow.camera.bottom = - 2;
		dirLight.shadow.camera.left = - 2;
		dirLight.shadow.camera.right = 2;
		dirLight.shadow.camera.near = 0.1;
		dirLight.shadow.camera.far = 40;
		scene.add( dirLight );

		// scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );

		// ground

		const Textloader = new THREE.TextureLoader(loadingManager);
		const groundTexture = Textloader.load('texture/carbon.png');
		groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
		groundTexture.repeat.set( 10, 10 );

		const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 30, 50 ), new THREE.MeshPhongMaterial( { map: groundTexture }) );
		mesh.rotation.x = - Math.PI / 2;
		mesh.receiveShadow = true;
		scene.add( mesh );

		const loader = new GLTFLoader(loadingManager);
		loader.load( 'models/gltf/Soldier.glb', function ( gltf ) {
			model = gltf.scene;
			scene.add( model );

			//Apply shadow
			model.traverse( function ( object ) {
				if ( object.isMesh ) object.castShadow = true;
			} );


			createPanel();

			const animations = gltf.animations;

			mixer = new THREE.AnimationMixer( model );

			idleAction = mixer.clipAction( animations[ 2 ] );
			walkAction = mixer.clipAction( animations[ 3 ] );
			runAction = mixer.clipAction( animations[ 1 ] );

			actions = [ idleAction, walkAction, runAction ];
			activateAllActions();
			animate();

		} );

		renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.outputEncoding = THREE.sRGBEncoding;
		renderer.shadowMap.enabled = true;
		container.appendChild( renderer.domElement );
		window.addEventListener( 'resize', onWindowResize );
	}

	function createPanel() {

		const panel = new GUI( { width: 310 } );

		const folder3 = panel.addFolder( 'Pausing/Stepping' );
		const folder4 = panel.addFolder( 'Crossfading' );
		const folder6 = panel.addFolder( 'Speed' );

		settings = {
			'show model': true,
			'pause/continue': pauseContinue,
			'from walk to idle': function () {

				prepareCrossFade( walkAction, idleAction, 1.0 );

			},
			'from idle to walk': function () {

				prepareCrossFade( idleAction, walkAction, 0.5 );

			},
			'from walk to run': function () {

				prepareCrossFade( walkAction, runAction, 2.5 );

			},
			'from run to walk': function () {

				prepareCrossFade( runAction, walkAction, 5.0 );

			},

			'set custom duration': 3.5,
			'modify walk weight': 1.0,
			'modify run weight': 0.0,
			'modify time scale': 1.0
		};

		folder3.add( settings, 'pause/continue' );
		crossFadeControls.push( folder4.add( settings, 'from walk to idle' ) );
		crossFadeControls.push( folder4.add( settings, 'from idle to walk' ) );
		crossFadeControls.push( folder4.add( settings, 'from walk to run' ) );
		crossFadeControls.push( folder4.add( settings, 'from run to walk' ) );
		folder6.add( settings, 'modify time scale', 0.0, 1.5, 0.01 ).onChange( modifyTimeScale );

		folder3.open();
		folder4.open();

		folder6.open();

		crossFadeControls.forEach( function ( control ) {
			control.classList1 = control.domElement.parentElement.parentElement.classList;
			control.classList2 = control.domElement.previousElementSibling.classList;

			control.setDisabled = function () {
				control.classList1.add( 'no-pointer-events' );
				control.classList2.add( 'control-disabled' );
			};

			control.setEnabled = function () {
				control.classList1.remove( 'no-pointer-events' );
				control.classList2.remove( 'control-disabled' );
			};
		} );
	}


	function modifyTimeScale( speed ) {
		mixer.timeScale = speed;
	}

	function activateAllActions() {
		setWeight( idleAction, settings[ 'modify idle weight' ] );
		setWeight( walkAction, settings[ 'modify walk weight' ] );
		setWeight( runAction, settings[ 'modify run weight' ] );
		actions.forEach( function ( action ) {
			action.play();
		} );
	}

	function pauseContinue() {
			if ( idleAction.paused ) {
				unPauseAllActions();
			} else {
				pauseAllActions();
			}
	}

	function pauseAllActions() {
		actions.forEach( function ( action ) {
			action.paused = true;
		} );
	}

	function unPauseAllActions() {
		actions.forEach( function ( action ) {
			action.paused = false;
		} );
	}


	function prepareCrossFade( startAction, endAction) {
		// idle = duration 4s => execute crossFade
		if ( startAction === idleAction ) {
			executeCrossFade( startAction, endAction, duration );
		} else {
			synchronizeCrossFade( startAction, endAction, duration );
		}
	}

	function setCrossFadeDuration( defaultDuration ) {
		// Switch default crossfade duration <-> custom crossfade duration
		if ( settings[ 'use default duration' ] ) {
			return defaultDuration;
		} else {
			return settings[ 'set custom duration' ];
		}
	}

	function synchronizeCrossFade( startAction, endAction, duration ) {
		mixer.addEventListener( 'loop', onLoopFinished );

		function onLoopFinished( event ) {
			if ( event.action === startAction ) {
				mixer.removeEventListener( 'loop', onLoopFinished );
				executeCrossFade( startAction, endAction, duration );
			}
		}
	}

	function executeCrossFade( startAction, endAction, duration ) {

		// start action,end action must get a weight of 1 before fading
		setWeight( endAction, 1 );
		endAction.time = 0;

		// Crossfade without warping
		startAction.crossFadeTo( endAction, duration, false );
	}

	//Set weight to the starting action
	function setWeight( action, weight ) {
		action.enabled = true;
		action.setEffectiveTimeScale( 1 );
		action.setEffectiveWeight( weight );

	}

	//Set weight when action
	function updateCrossFadeControls() {

		crossFadeControls.forEach(function ( control ) {

			control.setDisabled();

		} );

		if ( idleWeight === 1 && walkWeight === 0 && runWeight === 0 ) {

			crossFadeControls[ 1 ].setEnabled();

		}

		if ( idleWeight === 0 && walkWeight === 1 && runWeight === 0 ) {

			crossFadeControls[ 0 ].setEnabled();
			crossFadeControls[ 2 ].setEnabled();

		}

		if ( idleWeight === 0 && walkWeight === 0 && runWeight === 1 ) {

			crossFadeControls[ 3 ].setEnabled();
		}
	}

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		renderer.setSize( window.innerWidth, window.innerHeight );

	}

	function animate() {

		// Render loop
		requestAnimationFrame( animate );

		idleWeight = idleAction.getEffectiveWeight();
		walkWeight = walkAction.getEffectiveWeight();
		runWeight = runAction.getEffectiveWeight();



		// Enable/disable crossfade controls
		updateCrossFadeControls();

		//Get the seconds passed since the time oldTime was set and sets oldTime to the current time.(Not single step)
		let mixerUpdateDelta = clock.getDelta();

		// Update the animation mixer, the panel, and render this frame
		mixer.update( mixerUpdateDelta );
		renderer.render( scene, camera );

		function onTransitionEnd( event ) {

			event.target.remove();

		}

	}

</script>

</body>
</html>